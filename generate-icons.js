const fs = require('fs');
const path = require('path');

const ICONS_DIR = path.join(__dirname, '/public/svg/icons');
const OUTPUT_FILE = path.join(__dirname, '/src/shared/ui/kit/icon/index.tsx');

const OUTPUT_DIR = path.dirname(OUTPUT_FILE);

function toCamelCase(str) {
  return str
    .replace(/[-_](.)/g, (_, char) => char.toUpperCase())
    .replace(/^(.)/, (char) => char.toLowerCase());
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≤ kebab-case
function toKebabCase(str) {
  return str
    .replace(/([a-z])([A-Z])/g, '$1-$2') // camelCase -> kebab-case
    .replace(/[\s_]+/g, '-') // –ø—Ä–æ–±–µ–ª—ã –∏ underscores -> –¥–µ—Ñ–∏—Å—ã
    .replace(/[^a-zA-Z0-9-]/g, '') // —É–¥–∞–ª—è–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã
    .toLowerCase()
    .replace(/-+/g, '-') // –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –¥–µ—Ñ–∏—Å—ã -> –æ–¥–∏–Ω –¥–µ—Ñ–∏—Å
    .replace(/^-|-$/g, ''); // —É–±–∏—Ä–∞–µ–º –¥–µ—Ñ–∏—Å—ã –≤ –Ω–∞—á–∞–ª–µ –∏ –∫–æ–Ω—Ü–µ
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ SVG —Ñ–∞–π–ª–æ–≤ (–ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –∏ –∞–≤—Ç–æ–∑–∞–º–µ–Ω–∞ –∞—Ç—Ä–∏–±—É—Ç–æ–≤)
function processSvgFiles() {
  try {
    const files = fs
      .readdirSync(ICONS_DIR)
      .filter((file) => file.endsWith('.svg'));

    if (files.length === 0) {
      console.log('‚ùå SVG —Ñ–∞–π–ª—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ –ø–∞–ø–∫–µ:', ICONS_DIR);
      return;
    }

    console.log('üîÑ –û–±—Ä–∞–±–æ—Ç–∫–∞ SVG —Ñ–∞–π–ª–æ–≤...');

    let renamedCount = 0;
    let processedCount = 0;

    files.forEach((file) => {
      const filePath = path.join(ICONS_DIR, file);
      let svgContent = fs.readFileSync(filePath, 'utf8');
      let contentChanged = false;

      // –ê–≤—Ç–æ–∑–∞–º–µ–Ω–∞ SVG –∞—Ç—Ä–∏–±—É—Ç–æ–≤ –≤ camelCase —Ñ–æ—Ä–º–∞—Ç –¥–ª—è React
      const attributeReplacements = [
        { from: 'fill-opacity', to: 'fillOpacity' },
        { from: 'fill-rule', to: 'fillRule' },
        { from: 'clip-rule', to: 'clipRule' },
        { from: 'clip-path', to: 'clipPath' },
        { from: 'stroke-width', to: 'strokeWidth' },
        { from: 'stroke-linejoin', to: 'strokeLinejoin' },
        { from: 'stroke-linecap', to: 'strokeLinecap' }
      ];

      let hasChanges = false;
      attributeReplacements.forEach(({ from, to }) => {
        if (svgContent.includes(from)) {
          svgContent = svgContent.replace(new RegExp(from, 'g'), to);
          hasChanges = true;
        }
      });

      if (hasChanges) {
        fs.writeFileSync(filePath, svgContent, 'utf8');
        console.log(`  üîß –û–±—Ä–∞–±–æ—Ç–∞–Ω ${file}: SVG –∞—Ç—Ä–∏–±—É—Ç—ã ‚Üí camelCase`);
        contentChanged = true;
      }

      const fileName = path.basename(file, '.svg');
      const kebabName = toKebabCase(fileName);

      if (fileName !== kebabName) {
        const newPath = path.join(ICONS_DIR, `${kebabName}.svg`);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª —Å –Ω–æ–≤—ã–º –∏–º–µ–Ω–µ–º –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        if (fs.existsSync(newPath)) {
          console.log(
            `‚ö†Ô∏è  –§–∞–π–ª ${kebabName}.svg —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º ${file}`
          );
          return;
        }

        fs.renameSync(filePath, newPath);
        console.log(`  ‚úÖ ${file} ‚Üí ${kebabName}.svg`);
        renamedCount++;
      }

      if (contentChanged) {
        processedCount++;
      }
    });

    if (renamedCount === 0) {
      console.log('‚úÖ –í—Å–µ —Ñ–∞–π–ª—ã —É–∂–µ –≤ kebab-case —Ñ–æ—Ä–º–∞—Ç–µ');
    } else {
      console.log(`‚úÖ –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–æ ${renamedCount} —Ñ–∞–π–ª–æ–≤`);
    }

    if (processedCount === 0) {
      console.log('‚úÖ –í—Å–µ SVG —Ñ–∞–π–ª—ã —É–∂–µ —Å–æ–¥–µ—Ä–∂–∞—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –∞—Ç—Ä–∏–±—É—Ç—ã');
    } else {
      console.log(`‚úÖ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ ${processedCount} —Ñ–∞–π–ª–æ–≤ —Å –∑–∞–º–µ–Ω–æ–π –∞—Ç—Ä–∏–±—É—Ç–æ–≤`);
    }
    console.log('');
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–æ–≤:', error.message);
    throw error;
  }
}

function extractSvgContent(svgContent) {
  const match = svgContent.match(/<svg[^>]*>([\s\S]*?)<\/svg>/i);
  if (!match) return '';

  let content = match[1].trim();

  // –ê–≤—Ç–æ–∑–∞–º–µ–Ω–∞ SVG –∞—Ç—Ä–∏–±—É—Ç–æ–≤ –≤ camelCase —Ñ–æ—Ä–º–∞—Ç –¥–ª—è React JSX
  const attributeReplacements = [
    { from: 'fill-opacity', to: 'fillOpacity' },
    { from: 'fill-rule', to: 'fillRule' },
    { from: 'clip-rule', to: 'clipRule' },
    { from: 'clip-path', to: 'clipPath' },
    { from: 'stroke-width', to: 'strokeWidth' },
    { from: 'stroke-linejoin', to: 'strokeLinejoin' },
    { from: 'stroke-linecap', to: 'strokeLinecap' }
  ];

  attributeReplacements.forEach(({ from, to }) => {
    content = content.replace(new RegExp(from, 'g'), to);
  });

  return content;
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è viewBox –∏–∑ SVG
function extractViewBox(svgContent) {
  const match = svgContent.match(/viewBox="([^"]*)"/i);
  return match ? match[1] : '0 0 24 24';
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è width –∏–∑ SVG
function extractWidth(svgContent) {
  const match = svgContent.match(/width="([^"]*)"/i);
  return match ? parseInt(match[1]) || 24 : 24;
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è height –∏–∑ SVG
function extractHeight(svgContent) {
  const match = svgContent.match(/height="([^"]*)"/i);
  return match ? parseInt(match[1]) || 24 : 24;
}

// –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
function generateIconComponent() {
  try {
    // –°–Ω–∞—á–∞–ª–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º SVG —Ñ–∞–π–ª—ã (–ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –∏ –∞–≤—Ç–æ–∑–∞–º–µ–Ω–∞ –∞—Ç—Ä–∏–±—É—Ç–æ–≤)
    processSvgFiles();

    // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞, –µ—Å–ª–∏ –æ–Ω–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    if (!fs.existsSync(OUTPUT_DIR)) {
      fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }

    // –ß–∏—Ç–∞–µ–º –≤—Å–µ SVG —Ñ–∞–π–ª—ã
    const files = fs
      .readdirSync(ICONS_DIR)
      .filter((file) => file.endsWith('.svg'));

    if (files.length === 0) {
      console.log('‚ùå SVG —Ñ–∞–π–ª—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ –ø–∞–ø–∫–µ:', ICONS_DIR);
      return;
    }

    console.log(`üîç –ù–∞–π–¥–µ–Ω–æ ${files.length} SVG —Ñ–∞–π–ª–æ–≤:`);
    files.forEach((file) => console.log(`  - ${file}`));

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–∏–ø—ã –∏ –æ–±—ä–µ–∫—Ç —Å –∏–∫–æ–Ω–∫–∞–º–∏
    const iconNames = [];
    const iconObjects = [];

    files.forEach((file) => {
      const fileName = path.basename(file, '.svg');
      const kebabName = toCamelCase(fileName);
      const svgContent = fs.readFileSync(path.join(ICONS_DIR, file), 'utf8');

      const content = extractSvgContent(svgContent);
      const viewBox = extractViewBox(svgContent);
      const width = extractWidth(svgContent);
      const height = extractHeight(svgContent);

      if (!content) {
        console.log(`‚ö†Ô∏è  –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∏–∑ ${file}`);
        return;
      }

      iconNames.push(`'${kebabName}'`);
      iconObjects.push(`  '${kebabName}': {
    viewBox: '${viewBox}',
    width: ${width},
    height: ${height},
    content: (
      <>
        ${content
          .split('\n')
          .map((line) => line.trim())
          .filter(Boolean)
          .join('\n        ')}
      </>
    ),
  }`);
    });

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º TypeScript –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
    const componentContent = `import { SVGProps } from 'react'

interface IconProps extends SVGProps<SVGSVGElement> {
  name: ${iconNames.join(' | ')}
  width?: number
  height?: number
}

const icons = {
${iconObjects.join(',\n')}
} as const

export default function Icon({ name, width, height, className, ...props }: IconProps) {
  const icon = icons[name]
  
  if (!icon) {
    console.warn(\`Icon "\${name}" not found\`)
    return null
  }

  return (
    <svg
      width={width || icon.width}
      height={height || icon.height}
      viewBox={icon.viewBox}
      fill="none"
      className={className}
      role="img"
      aria-hidden="true"
      {...props}
    >
      {icon.content}
    </svg>
  )
}

// –≠–∫—Å–ø–æ—Ä—Ç –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∏–º–µ–Ω –∏–∫–æ–Ω–æ–∫ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
export const iconNames = [${iconNames.join(', ')}] as const
export type IconName = typeof iconNames[number]
`;

    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ñ–∞–π–ª
    fs.writeFileSync(OUTPUT_FILE, componentContent, 'utf8');

    console.log('‚úÖ –ö–æ–º–ø–æ–Ω–µ–Ω—Ç Icon —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω!');
    console.log(`üìÅ –§–∞–π–ª: ${OUTPUT_FILE}`);
    console.log(`üé® –î–æ—Å—Ç—É–ø–Ω—ã–µ –∏–∫–æ–Ω–∫–∏: ${iconNames.join(', ')}`);
    console.log('');
    console.log('üìã –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è:');
    console.log('  import Icon from "@/src/components/ui/Icon"');
    console.log('  <Icon name="book" width={20} height={20} />');
    console.log('  <Icon name="book" /> // –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã');
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞:', error.message);
    process.exit(1);
  }
}

// –ó–∞–ø—É—Å–∫ —Å–∫—Ä–∏–ø—Ç–∞
generateIconComponent();
